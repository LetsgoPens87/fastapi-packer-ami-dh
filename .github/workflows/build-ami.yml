name: Build AMI with Packer

on:
  workflow_dispatch:
    inputs:
      docker_image:
        description: 'Docker image to bake into AMI'
        required: true
        default: 'dhricko9/fastapi-simple:v3.0'
      environment:
        description: 'Environment (dev, staging, qa, prod)'
        required: false
        default: 'qa'

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  SUBNET_ID: subnet-0aad96ba58b95b06c
  PACKER_VERSION: "1.10.0"

jobs:
  build-ami:
    name: Build Golden AMI
    runs-on: ubuntu-latest
    outputs:
      ami_id: ${{ steps.ami.outputs.ami_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Packer
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity
          echo "âœ… AWS credentials configured successfully"

      - name: Setup Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Setup environment for Packer
        env:
          PACKER_GITHUB_API_TOKEN: ${{ secrets.PACKER_GITHUB_API_TOKEN }}
        run: |
          packer init packer.pkr.hcl

      - name: Initialize Packer
        run: packer init packer.pkr.hcl

      - name: Validate Packer template
        run: packer validate packer.pkr.hcl

      - name: Build AMI
        run: |
          packer build \
            -var "aws_region=${{ env.AWS_REGION }}" \
            -var "subnet_id=${{ env.SUBNET_ID }}" \
            -var "docker_image=${{ github.event.inputs.docker_image }}" \
            -var "environment=${{ github.event.inputs.environment }}" \
            packer.pkr.hcl

      - name: Extract AMI ID
        id: ami
        run: |
          AMI_ID=$(jq -r '.builds[-1].artifact_id' manifest.json | cut -d':' -f2)
          echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT
          echo "### AMI Build Complete! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**AMI ID:** \`$AMI_ID\`" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Docker Image:** ${{ github.event.inputs.docker_image }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Use this AMI ID in your Terraform configuration!" >> $GITHUB_STEP_SUMMARY

      - name: Upload manifest
        uses: actions/upload-artifact@v4
        with:
          name: packer-manifest
          path: manifest.json
          retention-days: 30

  test-ami:
    needs: build-ami
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: TestAMI
          aws-region: ${{ env.AWS_REGION }}

      - name: Download AMI ID from previous job
        run: echo "AMI_ID=${{ needs.build-ami.outputs.ami_id }}" >> $GITHUB_ENV

      # Run Dev environment test (optional placeholder, customize as needed)
      - name: Run EC2 Test (dev only)
        if: ${{ github.event.inputs.environment == 'dev' }}
        env:
          AMI_ID: ${{ env.AMI_ID }}
        run: |
          # Your dev test logic here...

      # Run QA zero-downtime verification
      - name: Verify Zero-Downtime Deployment (QA only)
        if: ${{ github.event.inputs.environment == 'qa' }}
        env:
          AMI_ID: ${{ env.AMI_ID }}
          SUBNET_ID: ${{ env.SUBNET_ID }}
        run: |
          # Retrieve VPC ID
          VPC_ID=$(aws ec2 describe-subnets --subnet-ids "$SUBNET_ID" --query 'Subnets[0].VpcId' --output text)
          if [ -z "$VPC_ID" ] || [ "$VPC_ID" == "None" ]; then
            echo "Could not retrieve VPC ID for subnet: $SUBNET_ID"
            exit 1
          fi
          echo "Using VPC: $VPC_ID"

          # Create security group
          SG_NAME="qa-zero-downtime-sg-$(date +%s)"
          SG_ID=$(aws ec2 create-security-group --group-name "$SG_NAME" --description "QA Zero-Downtime SG" --vpc-id "$VPC_ID" --query 'GroupId' --output text)
          echo "Created security group: $SG_ID"

          # Allow inbound HTTP
          aws ec2 authorize-security-group-ingress --group-id "$SG_ID" --protocol tcp --port 80 --cidr 0.0.0.0/0

          # Launch instance
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id "$AMI_ID" \
            --instance-type t2.micro \
            --security-group-ids "$SG_ID" \
            --subnet-id "$SUBNET_ID" \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=qa-zero-downtime}]" \
            --query 'Instances[0].InstanceId' --output text)
          echo "Launched instance: $INSTANCE_ID"

          # Wait for instance to be running
          aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"

          # Get the public IP
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "Instance IP: $PUBLIC_IP"

          # Wait longer for web server to initialize
          echo "Waiting 120 seconds for web server to initialize..."
          sleep 120

          # Retry checking web server responsiveness
          RETRIES=15
          SUCCESS=false
          for i in $(seq 1 $RETRIES); do
            echo "Attempt $i: Checking if web server is responsive..."
            curl -s --max-time 10 http://$PUBLIC_IP && SUCCESS=true && break
            echo "Web server not responding yet, retrying in 30 seconds..."
            sleep 30
          done

          if [ "$SUCCESS" != "true" ]; then
            echo "Failed to reach web server after $RETRIES attempts."
            # Cleanup
            aws ec2 terminate-instances --instance-ids "$INSTANCE_ID"
            exit 1
          fi

          # Check for expected page content
          RESPONSE=$(curl --silent --max-time 5 http://$PUBLIC_IP)
          if echo "$RESPONSE" | grep -q "Welcome to QA"; then
            echo "Page content verified."
          else
            echo "Expected content not found."
            aws ec2 terminate-instances --instance-ids "$INSTANCE_ID"
            exit 1
          fi

          # Cleanup
          aws ec2 terminate-instances --instance-ids "$INSTANCE_ID"
          echo "QA verification completed successfully."

      # Run Production rollout monitoring
      - name: Monitor Production Rollout
        if: ${{ github.event.inputs.environment == 'prod' }}
        env:
          AMI_ID: ${{ env.AMI_ID }}
          SUBNET_ID: ${{ env.SUBNET_ID }}
        run: |
          # Retrieve VPC ID
          VPC_ID=$(aws ec2 describe-subnets --subnet-ids "$SUBNET_ID" --query 'Subnets[0].VpcId' --output text)
          if [ -z "$VPC_ID" ] || [ "$VPC_ID" == "None" ]; then
            echo "Could not retrieve VPC ID for subnet: $SUBNET_ID"
            exit 1
          fi
          echo "Using VPC: $VPC_ID"

          # Create security group
          SG_NAME="prod-monitor-sg-$(date +%s)"
          SG_ID=$(aws ec2 create-security-group --group-name "$SG_NAME" --description "Prod rollout monitor SG" --vpc-id "$VPC_ID" --query 'GroupId' --output text)
          echo "Created security group: $SG_ID"

          # Allow inbound HTTP
          aws ec2 authorize-security-group-ingress --group-id "$SG_ID" --protocol tcp --port 80 --cidr 0.0.0.0/0

          # Launch monitoring instance
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id "$AMI_ID" \
            --instance-type t2.micro \
            --security-group-ids "$SG_ID" \
            --subnet-id "$SUBNET_ID" \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=prod-rollout-monitor}]" \
            --query 'Instances[0].InstanceId' --output text)
          echo "Launched monitoring instance: $INSTANCE_ID"

          # Wait for it to be running
          aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"

          # Get the public IP
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "Monitoring instance at: http://$PUBLIC_IP"

          # Wait until the app responds with 200 OK
          retries=10
          success=false
          for i in $(seq 1 $retries); do
            echo "Attempt $i: Checking if web server is responsive..."
            curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://$PUBLIC_IP | grep -q "200" && success=true && break
            echo "No response yet, retrying in 15 seconds..."
            sleep 15
          done

          if [ "$success" != "true" ]; then
            echo "Failed to get 200 OK after $retries attempts."
            aws ec2 terminate-instances --instance-ids "$INSTANCE_ID"
            exit 1
          fi

          # Check for specific content (adjust as needed)
          RESPONSE=$(curl --silent --max-time 5 http://$PUBLIC_IP)
          if echo "$RESPONSE" | grep -q "Expected Content or Health Indicator"; then
            echo "Application content verified."
          else
            echo "Expected content not found or health check failed."
            aws ec2 terminate-instances --instance-ids "$INSTANCE_ID"
            exit 1
          fi

          # Optional: monitor response time
          RESPONSE_TIME=$(curl -s -w "%{time_total}" -o /dev/null --max-time 5 http://$PUBLIC_IP)
          echo "Response time: $RESPONSE_TIME seconds"

          # Final cleanup
          aws ec2 terminate-instances --instance-ids "$INSTANCE_ID"
          echo "Production rollout verification completed successfully."