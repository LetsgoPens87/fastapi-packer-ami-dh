name: Build AMI with Packer

on:
  workflow_dispatch:
    inputs:
      docker_image:
        description: 'Docker image to bake into AMI'
        required: true
        default: 'dhricko9/fastapi-simple:v3.0'
      environment:
        description: 'Environment (dev, staging, prod)'
        required: false
        default: 'dev'

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  SUBNET_ID: subnet-078b5efdf09a3f8b7
  PACKER_VERSION: "1.10.0"

jobs:
  build-ami:
    name: Build Golden AMI
    runs-on: ubuntu-latest
    outputs:
      ami_id: ${{ steps.ami.outputs.ami_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Packer
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity
          echo "âœ… AWS credentials configured successfully"
      
      - name: Setup Packer
        uses: hashicorp/setup-packer@main
        with:
          version: ${{ env.PACKER_VERSION }}
      
      - name: Initialize Packer
        run: packer init packer.pkr.hcl
      
      - name: Validate Packer template
        run: packer validate packer.pkr.hcl
      
      - name: Build AMI
        run: |
          packer build \
            -var "aws_region=${{ env.AWS_REGION }}" \
            -var "subnet_id=${{ env.SUBNET_ID }}" \
            -var "docker_image=${{ github.event.inputs.docker_image || 'httpd:latest' }}" \
            -var "environment=${{ github.event.inputs.environment || 'dev' }}" \
            packer.pkr.hcl
      
      - name: Extract AMI ID
        id: ami
        run: |
          AMI_ID=$(jq -r '.builds[-1].artifact_id' manifest.json | cut -d':' -f2)
          echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT
          echo "### AMI Build Complete! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**AMI ID:** \`$AMI_ID\`" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Docker Image:** ${{ github.event.inputs.docker_image || 'httpd:latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Use this AMI ID in your Terraform configuration!" >> $GITHUB_STEP_SUMMARY
      
      - name: Upload manifest
        uses: actions/upload-artifact@v4
        with:
          name: packer-manifest
          path: manifest.json
          retention-days: 30

  test-ami:
    needs: build-ami
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: TestAMI
          aws-region: ${{ env.AWS_REGION }}

      - name: Download AMI ID from previous job
        run: echo "AMI_ID=${{ needs.build-ami.outputs.ami_id }}" >> $GITHUB_ENV

      - name: Run AMI Test
        env:
          AMI_ID: ${{ env.AMI_ID }}
        run: |
          # Paste your test script here, replacing $AMI_ID with the env variable
          # Example: run your test script you shared earlier
          # For simplicity, here's a placeholder:
          
          # Get default VPC
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" --query 'Vpcs[0].VpcId' --output text)

          # Get a subnet
          SUBNET_ID=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[0].SubnetId' --output text)

          # Create security group
          SG_ID=$(aws ec2 create-security-group \
            --group-name test-ami-sg \
            --description "Test AMI security group" \
            --vpc-id $VPC_ID \
            --query 'GroupId' --output text)

          # Allow HTTP
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 80 \
            --cidr 0.0.0.0/0

          # Launch instance with your AMI
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id $AMI_ID \
            --instance-type t2.micro \
            --security-group-ids $SG_ID \
            --subnet-id $SUBNET_ID \
            --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=ami-test}]' \
            --query 'Instances[0].InstanceId' --output text)

          echo "Instance launched: $INSTANCE_ID"

          # Wait for instance to be running
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID

          # Get public IP
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)

          echo "Access your app at: http://$PUBLIC_IP"

          # Wait a minute for the service to start, then test
          sleep 60
          curl http://$PUBLIC_IP
